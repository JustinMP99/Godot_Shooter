shader_type spatial;
render_mode unshaded, cull_front;

uniform sampler2D depth_tex : hint_depth_texture, repeat_disable;
uniform float outline_thickness : hint_range(0.0, 1.5, 0.01);
uniform float step_threshold : hint_range(0.0, 1.0, 0.01);
uniform vec3 outline_color : source_color = vec3(0.0, 0.0, 0.0);

float DepthVS(vec2 uv, mat4 inv_proj_mat)
{
	//Sample depth texture using passed in UV values
	float depth = texture(depth_tex, uv).r;

	return 1.0 / (depth * inv_proj_mat[2].w + inv_proj_mat[3].w);
}

void vertex() 
{
	POSITION = vec4(VERTEX.xy, 1,1);
}

void fragment() 
{

	float thickness = outline_thickness * 0.001;

	float depth = DepthVS(SCREEN_UV, INV_PROJECTION_MATRIX);

	float border_r = DepthVS(SCREEN_UV + vec2(thickness, 0), INV_PROJECTION_MATRIX) - depth;
	float border_l = DepthVS(SCREEN_UV - vec2(thickness, 0), INV_PROJECTION_MATRIX) - depth;
	float border_u = DepthVS(SCREEN_UV + vec2(0, thickness), INV_PROJECTION_MATRIX) - depth;
	float border_d = DepthVS(SCREEN_UV - vec2(0, thickness), INV_PROJECTION_MATRIX) - depth;

	float outline = clamp(border_d + border_l + border_r + border_u, 0, 1);

	outline = smoothstep(0, step_threshold, outline);

	ALBEDO = outline * outline_color;
	ALPHA = outline;
}

//void light() {
//	// Called for every pixel for every light affecting the material.
//	// Uncomment to replace the default light processing function with this one.
//}
